generator client {
  provider = "prisma-client-js"
}

datasource db {
  provider = "postgresql"
  url      = env("DATABASE_URL")
}

model User {
  id               String             @id @default(nanoid())
  avatarUrl        String
  mail             String             @unique
  username         String             @unique
  password         String?
  googleId         String?
  school42Id       String?
  doubleA          Boolean            @default(false)
  status           EStatus            @default(Online)
  languages        ELanguage          @default(English)
  level            Float              @default(0)
  createdAt        DateTime           @default(now())
  ChannelOwners    Channel[]
  ChannelMembers   ChannelMember[]
  Messages         ChannelMessage[]
  looser           GameStat[]         @relation("looserUser")
  winner           GameStat[]         @relation("winnerUser")
  userReceiver     PrivateMessage[]   @relation("userReceiver")
  userSender       PrivateMessage[]   @relation("userSender")
  userBlockeds     RelationBlocked[]  @relation("userBlocked")
  userBlocks       RelationBlocked[]  @relation("userBlock")
  relationFriendAs RelationFriend[]   @relation("relationFriendA")
  relationFriendBs RelationFriend[]   @relation("relationFriendB")
  requestReceivers RelationRequests[] @relation("requestReceiver")
  requestSenders   RelationRequests[] @relation("requestSender")
  userPresences    UserPresence[]
}

model UserPresence {
  id             String    @id @default(nanoid())
  userId         String
  connectedAt    DateTime  @default(now())
  disconnectedAt DateTime?
  isConnected    Boolean   @default(true)
  user           User      @relation(fields: [userId], references: [id], onDelete: Cascade)
}

model RelationFriend {
  userAId String
  userBId String
  userA   User   @relation("relationFriendA", fields: [userAId], references: [id], onDelete: Cascade)
  userB   User   @relation("relationFriendB", fields: [userBId], references: [id], onDelete: Cascade)

  @@id([userAId, userBId])
}

model RelationRequests {
  userSenderId   String
  userReceiverId String
  userB          User   @relation("requestReceiver", fields: [userReceiverId], references: [id], onDelete: Cascade)
  userA          User   @relation("requestSender", fields: [userSenderId], references: [id], onDelete: Cascade)

  @@id([userSenderId, userReceiverId])
}

model RelationBlocked {
  userBlockingId String
  userBlockedId  String
  userB          User   @relation("userBlocked", fields: [userBlockedId], references: [id], onDelete: Cascade)
  userA          User   @relation("userBlock", fields: [userBlockingId], references: [id], onDelete: Cascade)

  @@id([userBlockingId, userBlockedId])
}

model Channel {
  id        String           @id @default(nanoid())
  name      String           @unique
  avatarUrl String?
  topic     String?
  password  String?
  ownerId   String
  maxUsers  Int              @default(50)
  type      EChannelType     @default(Public)
  createdAt DateTime         @default(now())
  owner     User             @relation(fields: [ownerId], references: [id])
  members   ChannelMember[]
  messages  ChannelMessage[]
}

model ChannelMember {
  avatarUrl String
  nickname  String
  userId    String
  channelId String
  type      EMemeberType @default(Member)
  muted     Boolean      @default(false)
  juskakan  DateTime?
  createdAt DateTime     @default(now())
  channel   Channel      @relation(fields: [channelId], references: [id], onDelete: Cascade)
  user      User         @relation(fields: [userId], references: [id], onDelete: Cascade)

  @@id([userId, channelId])
}

model ChannelMessage {
  id        String      @id @default(nanoid())
  senderId  String
  channelId String
  content   String
  createdAt DateTime    @default(now())
  updatedAt DateTime?   @updatedAt
  channel   Channel     @relation(fields: [channelId], references: [id], onDelete: Cascade)
  user      User        @relation(fields: [senderId], references: [id])
}

model PrivateMessage {
  id         String   @id @default(nanoid())
  senderId   String
  receiverId String
  content    String
  updatedAt  DateTime? @updatedAt
  createdAt  DateTime @default(now())
  receiver   User     @relation("userReceiver", fields: [receiverId], references: [id])
  sender     User     @relation("userSender", fields: [senderId], references: [id])
}

model GameStat {
  id          String    @id @default(nanoid())
  winnerId    String?
  looserId    String?
  type        EGameType
  timePlayed  Int
  scoreWinner Int
  scoreLoser  Int
  createdAt   DateTime  @default(now())
  looser      User?      @relation("looserUser", fields: [looserId], references: [id], onDelete: SetNull)
  winner      User?      @relation("winnerUser", fields: [winnerId], references: [id], onDelete: SetNull)
}

enum EStatus {
  Online
  Invisble
  Idle
  DoNotDisturb
}

enum ELanguage {
  English
  French
  Spanish
}

enum EChannelType {
  Public
  Protected
  Private
}

enum EMemeberType {
  Admin
  Member
  Banned
  Invited
}

enum EGameType {
  Classic
  Special
}
